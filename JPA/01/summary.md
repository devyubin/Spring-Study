## JPA: 자바 ORM 표준 JPA 프로그래밍 - 기본편

> 01. JPA 소개
### JPA
#### 개요
- Java Persistence API
- 자바 진영의 ORM 기술 표준 (ORM: 객체 관계 매핑으로, 객체는 객체대로 관계형 DB는 DB대로 설계하며 ORM 프레임워크가 중간에서 매핑하는 것이다.)
- JPA는 애플리케이션과 JDBC 사이에서 동작
#### JPA를 사용해야 하는 이유
- SQL 중심적인 개발에서 객체 중심으로 개발 - 생산성
- 유지보수
- 패러다임의 불일치 해결
- 성능
- 데이터 접근 추상화와 벤더 독립성 - 표준
#### JPA의 성능 최적화 기능
1. 1차 캐시와 동일성(identity) 보장  
2. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)   
3. 지연 로딩(Lazy Loading)  
---
> 02. JPA 시작
### Hello JPA - 프로젝트 생성
#### H2 데이터베이스
- 최고의 실습용 DB 
- 가볍다.(1.5M)
- 웹용 쿼리툴 제공
- MySQL, Oracle 데이터베이스 시뮬레이션 기능
#### Maven
- 자바 라이브러리, 빌드 관리
- 라이브러리 자동 다운로드 및 의존성 관리
- 최근에는 그래들(Gradle)이 점점 유명
#### 프로젝트 생성
- 라이브러리 추가
- JPA 설정하기
#### 데이터베이스 방언
- JPA는 특정 데이터베이스에 종속 X
- 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다름
- 방언: SQL 표준을 지키지 않는 특정 데이터베이스만의 고유한 기능

### Hello JPA - 애플리케이션 개발
#### 실습
1. JPA 동작 확인 - JpaMain 클래스 생성
2. 회원 저장 - CRUD
3. JPQL을 통한 검색
#### JPQL 소개
- JPA를 사용하면 엔티티 객체를 중심으로 개발
- 문제는 검색 쿼리
- 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능
- 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검 색 조건이 포함된 SQL이 필요
- **JPQL은 엔티티 객체를 대상으로 쿼리**
- **SQL은 데이터베이스 테이블을 대상으로 쿼리**
---
> 03. 영속성 관리 (추후 복습 예정)
#### **JPA에서 가장 중요한 2가지: ORM & 영속성 컨텍스트**
### 영속성 컨텍스트
- JPA를 이해하는데 가장 중요한 용어 
- “엔티티를 영구 저장하는 환경”이라는 뜻 
- EntityManager.persist(entity);
J2SE 환경: 엔티티 매니저와 영속성 컨텍스트가 1:1
J2EE, 스프링 프레임워크 같은 컨테이너 환경: 엔티티 매니저와 영속성 컨텍스트가 N:1
#### 엔티티의 생명주기
- 비영속 (new/transient)  
영속성 컨텍스트와 전혀 관계가 없는 **새로운** 상태

- 영속 (managed)  
영속성 컨텍스트에 **관리**되는 상태

- 준영속 (detached)  
영속성 컨텍스트에 저장되었다가 **분리**된 상태

- 삭제 (removed)  
**삭제**된 상태

#### 영속성 컨텍스트의 이점
- 1차 캐시 
- 동일성(identity) 보장
- 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
- 변경 감지(Dirty Checking) 
- 지연 로딩(Lazy Loading)

#### 플러시
- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 영속성 컨텍스트를 비우지 않음: 변경내용을 DB에 동기화

#### 영속성 컨텍스트를 플러시하는 방법
- em.flush() - 직접 호출
- 트랜잭션 커밋 - 플러시 자동 호출 
- JPQL 쿼리 실행 - 플러시 자동 호출

#### 준영속 상태
- 영속 -> 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 
- 영속성 컨텍스트가 제공하는 기능을 사용 못함

#### 준영속 상태로 만드는 방법
- em.detach(entity)  
특정 엔티티만 준영속 상태로 전환
- em.clear()  
영속성 컨텍스트를 완전히 초기화
- em.close()  
영속성 컨텍스트를 종료

---
> 04. 엔티티 매핑 (추후 복습 예정)
#### 엔티티 매핑
- 객체와 테이블 매핑: `@Entity`, `@Table`
- 필드와 컬럼 매핑: `@Column`
- 기본 키 매핑: `@Id`
- 연관관계 매핑: `@ManyToOne`, `@JoinColumn`

#### 데이터베이스 스키마 자동 생성
- DDL을 애플리케이션 실행 시점에 자동 생성
- 테이블 중심 -> 객체 중심
- 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성
- **이렇게 생성된 DDL은 개발 장비에서만 사용**
- 생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용

#### 실습
- 스키마 자동 생성하기 설정
- 스키마 자동생성하기 실행, 옵션별 확인
- 데이터베이스 방언 별로 달라지는 것 확인(varchar)

\* 매핑 어노테이션 생략

#### 기본 키 매핑
- 기본 키 매핑 어노테이션
- 기본 키 매핑 방법
- @GeneratedValue의 IDENTITY / SEQUENCE / TABLE 전략

### 실전 예제 - 1. 요구사항 분석과 기본 매핑
- 요구사항 분석
- 도메인 모델 분석
- 테이블 설계 및 엔티티 설계와 매핑
---
### weeek 1 Trouble Shooting
H2 데이터 베이스를 활용하면서 많은 문제가 발생하였다. 스키마 중 update문 작성시 실행이 되지 않는 문제로 h2를 다운그레이드하면서, 실습 요구사항 분석을 진행하면서 H2의 기존 테이블이 삭제되지 않는 문제를 겪었고, 이에 대한 해결방법은 블로글에 작성하였다. [링크](https://dev-yubin.tistory.com/1) 이외에도 3강과 4강 일부에서 코드를 잘못 작성하여 제대로 실행되지 않은 부분이 있었다. 이에 대한 해결도 오랜 시간을 소모하였고, 그로 인해 이론적인 부분에 제대로 집중하지 못한 것 같아 추후 다시 학습할 계획이다.


---

> 05. 연관관계 매핑 기초
###
**연관관계의 주인** JPA계의 포인터(C언어)나 마찬가지. 매우 어렵다. 
객체지향적인 설계가 중요.

jpabook으로는 오류 발생. jpa basic으로 주요 코드 옮기기. 